[it-for-free/rusphp: вернуться к оглавлению](../README.md)

# Логгирование (отладка)

##  Распечатка -- Логгирование в файл или консоль ##

Используйте `ItForFree\rusphp\Log\SimpleEchoLog.php`:

```php
use /var/www/rusphp/Log/SimpleEchoLog.php as Log;
```
-- его фунции сами переносят строки (в html или фромате текстового файла 
в зависимости от значения статического параметра `Log::$inBrowserForHtml`)
для каждого очередного вызова.

 например:

* Обёртка над  echo:
```php
Log::me($value, 'первое значение');
Log::med($value, 'первое значение'); // после вывода вызовет die()
```
* Обёртка над print:
```php
Log::pre($value, 'первое значение');
Log::pred($value, 'первое значение'); // после вывода вызовет die()
```
эта и предыдущая обёртки обладают параметрами, отвественными за *число переносов строк*
до и после выводимого текста.

-- сама окружит вывод тэгами `<pre>` если вы работаете в html
* В нужном месте скрипта можно **выключить логгирование**:
```php
Log::off();
```
-- это позволяет не удлять инструкции из скрипта, если требуется почему-либо 
запустить код в среде, где логгировать нельзя (например, вы пока не уверены, \
что эти инструкции не потребуется в дальнейшем) 
А затем включить его:
```php
Log::on();
```
**ВНИМЕНИЕ:** не забывайте что выключенный где-то "до вас" логгер не будет работать, 
если не включить его, так как в данный момент активность определяется на основе статиеской переменной класса
-- фактически общей для всего скрипта. 


## Замеры времени выполнения разных участков кода ##

Использование  `ItForFree\Log\Time\Timer`:

```php
use ItForFree\rusphp\Log\Time\Timer;
use ItForFree\rusphp\Log\SimpleEchoLog;

// необязательно  но можно выставить эти и другие настройки:

Timer::maxUsefulLevel = 0.001;
Timer::roundAfterZeroTo = 4;

// начинаем замерять время выполнения
Timer::start('участок 1');
echo('123');
Timer::end('участок 1');

Timer::start('участок 2');
print_r('123');
Timer::end('участок 2');

Timer::me('участок 2'); // конкретный результат участка

// или можно получить сразу все результаты и распечатать их:
SimpleEchoLog::pre(Timer::getResults());
```

